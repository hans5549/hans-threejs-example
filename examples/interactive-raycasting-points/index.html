<!DOCTYPE html>
<html lang="zh-TW">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Three.js - Interactive Raycasting Points</title>
	<style>
		body {
			margin: 0;
			overflow: hidden;
			background-color: #000;
		}

		#container {
			width: 100%;
			height: 100vh;
		}

		#info {
			position: absolute;
			top: 10px;
			width: 100%;
			text-align: center;
			color: #fff;
			font-family: Arial, sans-serif;
			font-size: 14px;
			pointer-events: none;
			z-index: 100;
		}
	</style>
</head>
<body>
	<div id="container"></div>
	<div id="info">three.js - interactive raycasting points</div>

	<script type="importmap">
		{
			"imports": {
				"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
				"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
			}
		}
	</script>

	<script type="module">
		import * as THREE from 'three';
		import Stats from 'three/addons/libs/stats.module.js';

		// Global variables
		let container, stats;
		let renderer, scene, camera;
		let raycaster;
		let pointclouds;
		let intersection = null;
		let spheres = [];
		let spheresIndex = 0;
		let clock;
		let toggle = 0;

		const pointer = new THREE.Vector2();
		const threshold = 0.1;
		const pointSize = 0.05;
		const width = 80;
		const length = 160;
		const rotateY = new THREE.Matrix4().makeRotationY(0.005);

		init();

		function init() {
			container = document.getElementById('container');

			// Scene
			scene = new THREE.Scene();

			// Camera
			camera = new THREE.PerspectiveCamera(
				45,
				window.innerWidth / window.innerHeight,
				1,
				10000
			);
			camera.position.set(10, 10, 10);
			camera.lookAt(scene.position);

			// Clock
			clock = new THREE.Clock();

			// Point clouds
			const pcBuffer = generatePointcloud(new THREE.Color(1, 0, 0), width, length);
			pcBuffer.scale.set(5, 10, 10);
			pcBuffer.position.set(-5, 0, 0);
			scene.add(pcBuffer);

			const pcIndexed = generateIndexedPointcloud(new THREE.Color(0, 1, 0), width, length);
			pcIndexed.scale.set(5, 10, 10);
			pcIndexed.position.set(0, 0, 0);
			scene.add(pcIndexed);

			const pcIndexedOffset = generateIndexedWithOffsetPointcloud(new THREE.Color(0, 1, 1), width, length);
			pcIndexedOffset.scale.set(5, 10, 10);
			pcIndexedOffset.position.set(5, 0, 0);
			scene.add(pcIndexedOffset);

			pointclouds = [pcBuffer, pcIndexed, pcIndexedOffset];

			// Raycaster
			raycaster = new THREE.Raycaster();
			raycaster.params.Points.threshold = threshold;

			// Sphere markers pool
			const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);
			const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });

			for (let i = 0; i < 40; i++) {
				const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
				scene.add(sphere);
				spheres.push(sphere);
			}

			// Renderer
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setAnimationLoop(animate);
			container.appendChild(renderer.domElement);

			// Stats
			stats = new Stats();
			container.appendChild(stats.dom);

			// Event listeners
			window.addEventListener('resize', onWindowResize);
			document.addEventListener('pointermove', onPointerMove);
		}

		function generatePointCloudGeometry(color, width, length) {
			const geometry = new THREE.BufferGeometry();
			const numPoints = width * length;

			const positions = new Float32Array(numPoints * 3);
			const colors = new Float32Array(numPoints * 3);

			let k = 0;

			for (let i = 0; i < width; i++) {
				for (let j = 0; j < length; j++) {
					const u = i / width;
					const v = j / length;

					const x = u - 0.5;
					const y = (Math.cos(u * Math.PI * 4) + Math.sin(v * Math.PI * 8)) / 20;
					const z = v - 0.5;

					positions[3 * k] = x;
					positions[3 * k + 1] = y;
					positions[3 * k + 2] = z;

					const intensity = (y + 0.1) * 5;
					colors[3 * k] = color.r * intensity;
					colors[3 * k + 1] = color.g * intensity;
					colors[3 * k + 2] = color.b * intensity;

					k++;
				}
			}

			geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
			geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
			geometry.computeBoundingBox();

			return geometry;
		}

		function generatePointcloud(color, width, length) {
			const geometry = generatePointCloudGeometry(color, width, length);
			const material = new THREE.PointsMaterial({
				size: pointSize,
				vertexColors: true
			});

			return new THREE.Points(geometry, material);
		}

		function generateIndexedPointcloud(color, width, length) {
			const geometry = generatePointCloudGeometry(color, width, length);
			const numPoints = width * length;
			const indices = new Uint16Array(numPoints);

			for (let i = 0; i < numPoints; i++) {
				indices[i] = i;
			}

			geometry.setIndex(new THREE.BufferAttribute(indices, 1));

			const material = new THREE.PointsMaterial({
				size: pointSize,
				vertexColors: true
			});

			return new THREE.Points(geometry, material);
		}

		function generateIndexedWithOffsetPointcloud(color, width, length) {
			const geometry = generatePointCloudGeometry(color, width, length);
			const numPoints = width * length;
			const indices = new Uint16Array(numPoints);

			for (let i = 0; i < numPoints; i++) {
				indices[i] = i;
			}

			geometry.setIndex(new THREE.BufferAttribute(indices, 1));
			geometry.addGroup(0, indices.length);

			const material = new THREE.PointsMaterial({
				size: pointSize,
				vertexColors: true
			});

			return new THREE.Points(geometry, material);
		}

		function onPointerMove(event) {
			pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
			pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
		}

		function onWindowResize() {
			const minWidth = Math.max(window.innerWidth, 320);
			const minHeight = Math.max(window.innerHeight, 240);

			camera.aspect = minWidth / minHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(minWidth, minHeight);
		}

		function animate() {
			render();
			stats.update();
		}

		function render() {
			// Camera rotation
			camera.applyMatrix4(rotateY);
			camera.updateMatrixWorld();

			// Raycasting
			raycaster.setFromCamera(pointer, camera);

			const intersections = raycaster.intersectObjects(pointclouds, false);
			intersection = (intersections.length > 0) ? intersections[0] : null;

			// Place marker with throttle
			if (toggle > 0.02 && intersection !== null) {
				spheres[spheresIndex].position.copy(intersection.point);
				spheres[spheresIndex].scale.set(1, 1, 1);
				spheresIndex = (spheresIndex + 1) % spheres.length;

				toggle = 0;
			}

			// Animate all spheres (shrink)
			for (let i = 0; i < spheres.length; i++) {
				const sphere = spheres[i];
				sphere.scale.multiplyScalar(0.98);
				sphere.scale.clampScalar(0.01, 1);
			}

			toggle += clock.getDelta();

			// Render
			renderer.render(scene, camera);
		}
	</script>
</body>
</html>
