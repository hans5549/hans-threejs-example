<!DOCTYPE html>
<html lang="en">
<head>
	<title>Three.js WebGL - Geometry - Spline Editor</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			margin: 0;
			overflow: hidden;
			background-color: #f0f0f0;
		}
	</style>
</head>
<body>
	<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.170.0/build/three.module.js",
			"three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
		}
	}
	</script>

	<script type="module">
		import * as THREE from 'three';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { TransformControls } from 'three/addons/controls/TransformControls.js';

		// ===========================================
		// Global Variables
		// ===========================================
		let container;
		let camera, scene, renderer;
		let orbitControls, transformControl;
		
		const splineHelperObjects = [];
		let splinePointsLength = 4;
		const positions = [];
		const point = new THREE.Vector3();
		
		const raycaster = new THREE.Raycaster();
		const pointer = new THREE.Vector2();
		const onUpPosition = new THREE.Vector2();
		const onDownPosition = new THREE.Vector2();
		
		const ARC_SEGMENTS = 200;
		
		const splines = {};
		
		const params = {
			uniform: true,
			tension: 0.5,
			centripetal: true,
			chordal: true,
			addPoint: addPoint,
			removePoint: removePoint,
			exportSpline: exportSpline
		};

		// Control point box geometry (shared)
		const boxGeometry = new THREE.BoxGeometry( 20, 20, 20 );

		// ===========================================
		// Default Control Points
		// ===========================================
		const defaultPositions = [
			new THREE.Vector3( 289.76843686945404, 452.51481137238443, 56.10018915737797 ),
			new THREE.Vector3( -53.56300074753207, 171.49711742836848, -14.495472686253045 ),
			new THREE.Vector3( -91.40118730204415, 176.4306956436485, -6.958271935582161 ),
			new THREE.Vector3( -383.785318791128, 491.1365363371675, 47.869296953772746 )
		];

		// ===========================================
		// Initialization
		// ===========================================
		init();

		function init() {
			container = document.createElement( 'div' );
			document.body.appendChild( container );

			// Scene
			scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xf0f0f0 );

			// Camera
			camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
			camera.position.set( 0, 250, 1000 );
			scene.add( camera );

			// Ambient Light
			scene.add( new THREE.AmbientLight( 0xf0f0f0, 3 ) );

			// Spot Light with shadows
			const spotLight = new THREE.SpotLight( 0xffffff, 4.5 );
			spotLight.position.set( 0, 1500, 200 );
			spotLight.angle = Math.PI * 0.2;
			spotLight.decay = 0;
			spotLight.castShadow = true;
			spotLight.shadow.camera.near = 200;
			spotLight.shadow.camera.far = 2000;
			spotLight.shadow.bias = - 0.000222;
			spotLight.shadow.mapSize.width = 1024;
			spotLight.shadow.mapSize.height = 1024;
			scene.add( spotLight );

			// Ground Plane
			const planeGeometry = new THREE.PlaneGeometry( 2000, 2000 );
			planeGeometry.rotateX( - Math.PI / 2 );
			const planeMaterial = new THREE.ShadowMaterial( { color: 0x000000, opacity: 0.2 } );
			const plane = new THREE.Mesh( planeGeometry, planeMaterial );
			plane.position.y = - 200;
			plane.receiveShadow = true;
			scene.add( plane );

			// Grid Helper
			const gridHelper = new THREE.GridHelper( 2000, 100 );
			gridHelper.position.y = - 199;
			gridHelper.material.opacity = 0.25;
			gridHelper.material.transparent = true;
			scene.add( gridHelper );

			// Renderer
			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;
			container.appendChild( renderer.domElement );

			// GUI
			const gui = new GUI();
			gui.add( params, 'uniform' ).onChange( render );
			gui.add( params, 'tension', 0, 1 ).step( 0.01 ).onChange( function( value ) {
				splines.uniform.tension = value;
				updateSplineOutline();
				render();
			} );
			gui.add( params, 'centripetal' ).onChange( render );
			gui.add( params, 'chordal' ).onChange( render );
			gui.add( params, 'addPoint' );
			gui.add( params, 'removePoint' );
			gui.add( params, 'exportSpline' );
			gui.open();

			// Orbit Controls
			orbitControls = new OrbitControls( camera, renderer.domElement );
			orbitControls.damping = 0.2;
			orbitControls.addEventListener( 'change', render );

			// Transform Controls
			transformControl = new TransformControls( camera, renderer.domElement );
			transformControl.addEventListener( 'change', render );
			transformControl.addEventListener( 'dragging-changed', function( event ) {
				orbitControls.enabled = ! event.value;
			} );
			transformControl.addEventListener( 'objectChange', function() {
				updateSplineOutline();
			} );
			scene.add( transformControl.getHelper() );

			// Load default control points
			load( defaultPositions );

			// Create splines (three curve types)
			// Uniform (catmullrom) - Red
			splines.uniform = new THREE.CatmullRomCurve3( positions );
			splines.uniform.curveType = 'catmullrom';
			splines.uniform.tension = params.tension;
			splines.uniform.mesh = createSplineMesh( splines.uniform, 0xff0000 );
			scene.add( splines.uniform.mesh );

			// Centripetal - Green
			splines.centripetal = new THREE.CatmullRomCurve3( positions );
			splines.centripetal.curveType = 'centripetal';
			splines.centripetal.mesh = createSplineMesh( splines.centripetal, 0x00ff00 );
			scene.add( splines.centripetal.mesh );

			// Chordal - Blue
			splines.chordal = new THREE.CatmullRomCurve3( positions );
			splines.chordal.curveType = 'chordal';
			splines.chordal.mesh = createSplineMesh( splines.chordal, 0x0000ff );
			scene.add( splines.chordal.mesh );

			// Update spline outlines
			updateSplineOutline();

			// Event listeners
			document.addEventListener( 'pointerdown', onPointerDown );
			document.addEventListener( 'pointerup', onPointerUp );
			window.addEventListener( 'resize', onWindowResize );

			render();
		}

		// ===========================================
		// Control Point Functions
		// ===========================================
		function addSplineObject( position ) {
			const material = new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } );
			const object = new THREE.Mesh( boxGeometry, material );

			if ( position ) {
				object.position.copy( position );
			} else {
				object.position.x = Math.random() * 1000 - 500;
				object.position.y = Math.random() * 600;
				object.position.z = Math.random() * 800 - 400;
			}

			object.castShadow = true;
			object.receiveShadow = true;
			scene.add( object );
			splineHelperObjects.push( object );
			return object;
		}

		function addPoint() {
			splinePointsLength ++;
			positions.push( addSplineObject().position );
			updateSplineOutline();
			render();
		}

		function removePoint() {
			if ( splinePointsLength <= 4 ) return;

			const point = splineHelperObjects.pop();
			splinePointsLength --;
			positions.pop();

			if ( transformControl.object === point ) {
				transformControl.detach();
			}

			scene.remove( point );
			updateSplineOutline();
			render();
		}

		function load( newPositions ) {
			// Clear existing control points
			while ( splineHelperObjects.length > 0 ) {
				const object = splineHelperObjects.pop();
				scene.remove( object );
			}

			// Reset positions array
			positions.length = 0;

			// Create new control points
			for ( let i = 0; i < newPositions.length; i ++ ) {
				const object = addSplineObject( newPositions[ i ] );
				positions.push( object.position );
			}

			splinePointsLength = newPositions.length;
		}

		// ===========================================
		// Spline Functions
		// ===========================================
		function createSplineMesh( curve, color ) {
			const geometry = new THREE.BufferGeometry();
			geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( ARC_SEGMENTS * 3 ), 3 ) );
			const material = new THREE.LineBasicMaterial( { color: color, opacity: 0.35, linewidth: 2 } );
			return new THREE.Line( geometry, material );
		}

		function updateSplineOutline() {
			for ( const k in splines ) {
				const spline = splines[ k ];
				const splineMesh = spline.mesh;
				const position = splineMesh.geometry.attributes.position;

				for ( let i = 0; i < ARC_SEGMENTS; i ++ ) {
					const t = i / ( ARC_SEGMENTS - 1 );
					spline.getPoint( t, point );
					position.setXYZ( i, point.x, point.y, point.z );
				}

				position.needsUpdate = true;
			}
		}

		function exportSpline() {
			const strplace = [];
			for ( let i = 0; i < splinePointsLength; i ++ ) {
				const p = splineHelperObjects[ i ].position;
				strplace.push( `new THREE.Vector3( ${ p.x }, ${ p.y }, ${ p.z } )` );
			}
			console.log( strplace.join( ',\n' ) );

			const code = '[\n\t' + strplace.join( ',\n\t' ) + '\n]';
			prompt( 'Copy to clipboard: Ctrl+C, Enter', code );
		}

		// ===========================================
		// Event Handlers
		// ===========================================
		function onPointerDown( event ) {
			onDownPosition.x = event.clientX;
			onDownPosition.y = event.clientY;
		}

		function onPointerUp( event ) {
			onUpPosition.x = event.clientX;
			onUpPosition.y = event.clientY;

			if ( onDownPosition.distanceTo( onUpPosition ) === 0 ) {
				transformControl.detach();
				render();
			}
		}

		function onClick( event ) {
			pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			raycaster.setFromCamera( pointer, camera );
			const intersects = raycaster.intersectObjects( splineHelperObjects, false );

			if ( intersects.length > 0 ) {
				const object = intersects[ 0 ].object;
				if ( object !== transformControl.object ) {
					transformControl.attach( object );
				}
			} else {
				transformControl.detach();
			}

			render();
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
			render();
		}

		// ===========================================
		// Render Function
		// ===========================================
		function render() {
			splines.uniform.mesh.visible = params.uniform;
			splines.centripetal.mesh.visible = params.centripetal;
			splines.chordal.mesh.visible = params.chordal;
			renderer.render( scene, camera );
		}

		// Add click event listener separately from pointer events
		document.addEventListener( 'click', onClick );

	</script>
</body>
</html>
