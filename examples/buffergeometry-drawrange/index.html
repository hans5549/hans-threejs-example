<!DOCTYPE html>
<html lang="zh-TW">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Three.js - BufferGeometry DrawRange 互動式粒子網絡</title>
	<style>
		body {
			margin: 0;
			background-color: #000;
			color: #fff;
			font-family: Monospace;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 10px;
			width: 100%;
			text-align: center;
			z-index: 100;
			pointer-events: none;
		}

		#info a {
			color: #0af;
			pointer-events: auto;
		}

		#container {
			width: 100%;
			height: 100vh;
		}
	</style>
</head>
<body>
	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - BufferGeometry DrawRange 互動式粒子網絡
	</div>
	<div id="container"></div>

	<script type="importmap">
		{
			"imports": {
				"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
				"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
			}
		}
	</script>

	<script type="module">
		import * as THREE from 'three';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import Stats from 'three/addons/libs/stats.module.js';

		// 全域變數
		let container, stats;
		let camera, scene, renderer, controls;
		let group;

		// 粒子系統
		let particles;
		let pointCloud;
		let particlePositions;

		// 連線系統
		let positions;
		let colors;
		let linesMesh;

		// 資料陣列
		const particlesData = [];

		// 常數
		const maxParticleCount = 1000;
		let particleCount = 500;
		const r = 800;
		const rHalf = r / 2;

		// GUI 控制器
		const effectController = {
			showDots: true,
			showLines: true,
			minDistance: 150,
			limitConnections: false,
			maxConnections: 20,
			particleCount: 500
		};

		/**
		 * 初始化 GUI 控制面板
		 */
		function initGUI() {
			const gui = new GUI();

			gui.add(effectController, 'showDots').onChange(function (value) {
				pointCloud.visible = value;
			});

			gui.add(effectController, 'showLines').onChange(function (value) {
				linesMesh.visible = value;
			});

			gui.add(effectController, 'minDistance', 10, 300);
			gui.add(effectController, 'limitConnections');
			gui.add(effectController, 'maxConnections', 0, 30, 1);

			gui.add(effectController, 'particleCount', 0, maxParticleCount, 1).onChange(function (value) {
				particleCount = value;
				particles.setDrawRange(0, particleCount);
			});
		}

		/**
		 * 初始化場景
		 */
		function init() {
			initGUI();

			container = document.getElementById('container');

			// 建立攝影機
			camera = new THREE.PerspectiveCamera(
				45,
				window.innerWidth / window.innerHeight,
				1,
				4000
			);
			camera.position.z = 1750;

			// 建立場景和群組
			scene = new THREE.Scene();
			group = new THREE.Group();
			scene.add(group);

			// 建立邊界框輔助線
			const helper = new THREE.BoxHelper(
				new THREE.Mesh(new THREE.BoxGeometry(r, r, r))
			);
			helper.material.color.setHex(0x474747);
			helper.material.blending = THREE.AdditiveBlending;
			helper.material.transparent = true;
			group.add(helper);

			// 計算線段陣列所需大小
			const segments = maxParticleCount * maxParticleCount;

			// 建立連線用的緩衝區
			positions = new Float32Array(segments * 3);
			colors = new Float32Array(segments * 3);

			// 建立粒子位置緩衝區
			particlePositions = new Float32Array(maxParticleCount * 3);

			// 初始化粒子位置和速度
			for (let i = 0; i < maxParticleCount; i++) {
				const x = Math.random() * r - rHalf;
				const y = Math.random() * r - rHalf;
				const z = Math.random() * r - rHalf;

				particlePositions[i * 3] = x;
				particlePositions[i * 3 + 1] = y;
				particlePositions[i * 3 + 2] = z;

				particlesData.push({
					velocity: new THREE.Vector3(
						-1 + Math.random() * 2,
						-1 + Math.random() * 2,
						-1 + Math.random() * 2
					),
					numConnections: 0
				});
			}

			// 建立粒子 BufferGeometry
			particles = new THREE.BufferGeometry();
			particles.setDrawRange(0, particleCount);
			particles.setAttribute(
				'position',
				new THREE.BufferAttribute(particlePositions, 3).setUsage(THREE.DynamicDrawUsage)
			);

			// 建立粒子材質
			const pMaterial = new THREE.PointsMaterial({
				color: 0xffffff,
				size: 3,
				blending: THREE.AdditiveBlending,
				transparent: true,
				sizeAttenuation: false
			});

			// 建立粒子點雲
			pointCloud = new THREE.Points(particles, pMaterial);
			group.add(pointCloud);

			// 建立連線 BufferGeometry
			const geometry = new THREE.BufferGeometry();
			geometry.setAttribute(
				'position',
				new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage)
			);
			geometry.setAttribute(
				'color',
				new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage)
			);
			geometry.computeBoundingSphere();
			geometry.setDrawRange(0, 0);

			// 建立連線材質
			const material = new THREE.LineBasicMaterial({
				vertexColors: true,
				blending: THREE.AdditiveBlending,
				transparent: true
			});

			// 建立連線網格
			linesMesh = new THREE.LineSegments(geometry, material);
			group.add(linesMesh);

			// 建立渲染器
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setAnimationLoop(animate);
			container.appendChild(renderer.domElement);

			// 建立軌道控制器
			controls = new OrbitControls(camera, container);
			controls.minDistance = 1000;
			controls.maxDistance = 3000;

			// 建立效能統計
			stats = new Stats();
			container.appendChild(stats.dom);

			// 綁定視窗大小變化事件
			window.addEventListener('resize', onWindowResize);
		}

		/**
		 * 處理視窗大小變化
		 */
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		/**
		 * 動畫迴圈
		 */
		function animate() {
			let vertexpos = 0;
			let colorpos = 0;
			let numConnected = 0;

			// 重置連接計數
			for (let i = 0; i < particleCount; i++) {
				particlesData[i].numConnections = 0;
			}

			// 更新粒子位置
			for (let i = 0; i < particleCount; i++) {
				const particleData = particlesData[i];

				particlePositions[i * 3] += particleData.velocity.x;
				particlePositions[i * 3 + 1] += particleData.velocity.y;
				particlePositions[i * 3 + 2] += particleData.velocity.z;

				// X 軸邊界檢查
				if (particlePositions[i * 3] < -rHalf || particlePositions[i * 3] > rHalf) {
					particleData.velocity.x = -particleData.velocity.x;
				}

				// Y 軸邊界檢查
				if (particlePositions[i * 3 + 1] < -rHalf || particlePositions[i * 3 + 1] > rHalf) {
					particleData.velocity.y = -particleData.velocity.y;
				}

				// Z 軸邊界檢查
				if (particlePositions[i * 3 + 2] < -rHalf || particlePositions[i * 3 + 2] > rHalf) {
					particleData.velocity.z = -particleData.velocity.z;
				}

				// 檢查連線限制
				if (effectController.limitConnections && particleData.numConnections >= effectController.maxConnections) {
					continue;
				}

				// 計算與其他粒子的距離
				for (let j = i + 1; j < particleCount; j++) {
					const particleDataB = particlesData[j];

					if (effectController.limitConnections && particleDataB.numConnections >= effectController.maxConnections) {
						continue;
					}

					const dx = particlePositions[i * 3] - particlePositions[j * 3];
					const dy = particlePositions[i * 3 + 1] - particlePositions[j * 3 + 1];
					const dz = particlePositions[i * 3 + 2] - particlePositions[j * 3 + 2];
					const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

					if (dist < effectController.minDistance) {
						particleData.numConnections++;
						particleDataB.numConnections++;

						const alpha = 1.0 - dist / effectController.minDistance;

						// 寫入第一個頂點
						positions[vertexpos++] = particlePositions[i * 3];
						positions[vertexpos++] = particlePositions[i * 3 + 1];
						positions[vertexpos++] = particlePositions[i * 3 + 2];

						// 寫入第二個頂點
						positions[vertexpos++] = particlePositions[j * 3];
						positions[vertexpos++] = particlePositions[j * 3 + 1];
						positions[vertexpos++] = particlePositions[j * 3 + 2];

						// 寫入顏色（兩個頂點使用相同的 alpha）
						colors[colorpos++] = alpha;
						colors[colorpos++] = alpha;
						colors[colorpos++] = alpha;

						colors[colorpos++] = alpha;
						colors[colorpos++] = alpha;
						colors[colorpos++] = alpha;

						numConnected++;
					}
				}
			}

			// 更新連線幾何體
			linesMesh.geometry.setDrawRange(0, numConnected * 2);
			linesMesh.geometry.attributes.position.needsUpdate = true;
			linesMesh.geometry.attributes.color.needsUpdate = true;

			// 更新粒子幾何體
			pointCloud.geometry.attributes.position.needsUpdate = true;

			render();
			stats.update();
		}

		/**
		 * 渲染場景
		 */
		function render() {
			const time = Date.now() * 0.001;
			group.rotation.y = time * 0.1;
			renderer.render(scene, camera);
		}

		// 啟動應用程式
		init();
	</script>
</body>
</html>
