<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Raycaster BVH - 高效能光線投射展示</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
        }
        
        canvas {
            display: block;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            font-size: 18px;
            z-index: 1000;
        }
        
        #loading-progress {
            margin-top: 20px;
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        
        #loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s ease;
        }
        
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(244, 67, 54, 0.9);
            color: #fff;
            padding: 20px 30px;
            border-radius: 8px;
            text-align: center;
            display: none;
            z-index: 1001;
            max-width: 500px;
        }
        
        #error h3 {
            margin: 0 0 10px 0;
        }
        
        #performance-warning {
            position: absolute;
            top: 80px;
            left: 10px;
            background: rgba(255, 152, 0, 0.9);
            color: #fff;
            padding: 10px 15px;
            border-radius: 4px;
            display: none;
            z-index: 100;
            font-size: 14px;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 14px;
            line-height: 1.6;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 4px;
            z-index: 10;
        }
        
        #info a {
            color: #4CAF50;
            text-decoration: none;
        }
        
        #info a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>WebGL Raycaster BVH</strong><br>
        展示 BVH 加速結構對光線投射效能的影響<br>
        使用滑鼠旋轉和縮放場景
    </div>
    
    <div id="loading">
        <div>載入 3D 模型中...</div>
        <div id="loading-progress">
            <div id="loading-bar"></div>
        </div>
        <div id="loading-text" style="margin-top: 10px; font-size: 14px; color: #aaa;">0%</div>
    </div>
    
    <div id="error">
        <h3>載入失敗</h3>
        <p id="error-message"></p>
    </div>
    
    <div id="performance-warning">
        ⚠️ FPS 過低 - 建議減少光線數量或啟用 BVH 加速
    </div>

    <!-- Three.js Core -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import Stats from 'https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js';
        import { GUI } from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.min.js';
        import { 
            computeBoundsTree, 
            disposeBoundsTree, 
            acceleratedRaycast,
            MeshBVHHelper
        } from 'https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.7.3/build/index.module.js';

        // ==================== 全域變數 ====================
        let scene, camera, renderer, controls, stats;
        let model, raycaster;
        let rayOriginsGroup, intersectionPointsGroup, rayLinesGroup;
        let bvhHelper;
        let gui;
        let performanceMonitor;
        
        // ==================== 狀態管理 ====================
        const loadingState = {
            status: 'idle', // 'idle' | 'loading' | 'building' | 'ready' | 'error'
            progress: 0,
            message: '',
            startTime: 0
        };
        
        const guiParams = {
            rayCount: 100,
            enableBVH: true,
            showBVHHelper: false,
            helperDepth: 10,
            rayOpacity: 0.5,
            animate: true
        };
        
        // ==================== BVH 擴展 ====================
        // 擴展 BufferGeometry 原型以支援 BVH
        THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
        THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
        THREE.Mesh.prototype.raycast = acceleratedRaycast;
        
        // ==================== 效能監控類別 ====================
        class PerformanceMonitor {
            constructor() {
                this.fpsHistory = [];
                this.maxHistoryLength = 60; // 60 幀
                this.warningThreshold = 30;
                this.warningActive = false;
            }
            
            update(fps) {
                this.fpsHistory.push(fps);
                if (this.fpsHistory.length > this.maxHistoryLength) {
                    this.fpsHistory.shift();
                }
            }
            
            getAverageFPS() {
                if (this.fpsHistory.length === 0) return 0;
                const sum = this.fpsHistory.reduce((a, b) => a + b, 0);
                return sum / this.fpsHistory.length;
            }
            
            checkWarning() {
                const avgFPS = this.getAverageFPS();
                const shouldWarn = avgFPS < this.warningThreshold && this.fpsHistory.length >= 30;
                
                if (shouldWarn && !this.warningActive) {
                    this.warningActive = true;
                    showPerformanceWarning(true);
                } else if (!shouldWarn && this.warningActive) {
                    this.warningActive = false;
                    showPerformanceWarning(false);
                }
            }
        }
        
        // ==================== 初始化函式 ====================
        function init() {
            // 建立場景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // 建立攝影機
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                100
            );
            camera.position.set(0, 2, 5);
            
            // 建立渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // 建立軌道控制
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 2;
            controls.maxDistance = 10;
            
            // 建立光照
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(5, 10, 5);
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-5, -5, -5);
            scene.add(directionalLight2);
            
            // 建立 Raycaster
            raycaster = new THREE.Raycaster();
            raycaster.firstHitOnly = false;
            
            // 建立 Stats.js
            stats = new Stats();
            stats.dom.style.position = 'absolute';
            stats.dom.style.top = '10px';
            stats.dom.style.right = '10px';
            document.body.appendChild(stats.dom);
            
            // 建立效能監控器
            performanceMonitor = new PerformanceMonitor();
            
            // 建立 GUI
            createGUI();
            
            // 視窗大小調整
            window.addEventListener('resize', onWindowResize);
            
            // 載入模型
            loadModel();
        }
        
        // ==================== 視窗大小調整 ====================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // ==================== 模型載入 ====================
        function loadModel() {
            loadingState.status = 'loading';
            loadingState.startTime = Date.now();
            showLoading(true);
            
            const loader = new FBXLoader();
            const loadingManager = new THREE.LoadingManager();
            
            // 進度監聽
            loadingManager.onProgress = (url, loaded, total) => {
                const progress = (loaded / total) * 100;
                updateLoadingProgress(progress);
            };
            
            // 60 秒逾時
            const timeout = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('載入逾時 (超過 60 秒)')), 60000);
            });
            
            // 載入模型
            const loadPromise = new Promise((resolve, reject) => {
                loader.setLoadingManager(loadingManager);
                loader.load(
                    'https://threejs.org/examples/models/fbx/stanford-bunny.fbx',
                    (object) => resolve(object),
                    undefined,
                    (error) => reject(error)
                );
            });
            
            // 使用 Promise.race 實現逾時
            Promise.race([loadPromise, timeout])
                .then((object) => {
                    model = object;
                    
                    // 調整模型
                    model.scale.multiplyScalar(0.01);
                    model.position.set(0, 0, 0);
                    
                    // 取得網格
                    const mesh = model.children[0];
                    if (mesh && mesh.geometry) {
                        // 設定材質
                        mesh.material = new THREE.MeshStandardMaterial({
                            color: 0x888888,
                            roughness: 0.5,
                            metalness: 0.3
                        });
                        
                        // 建構 BVH
                        loadingState.status = 'building';
                        updateLoadingProgress(100, '建構 BVH 加速結構...');
                        
                        setTimeout(() => {
                            buildBVH(mesh);
                            
                            scene.add(model);
                            
                            // 產生光線
                            initializeRays();
                            
                            loadingState.status = 'ready';
                            showLoading(false);
                            
                            // 開始動畫
                            animate();
                        }, 100);
                    }
                })
                .catch((error) => {
                    console.error('模型載入失敗:', error);
                    loadingState.status = 'error';
                    showError(error.message || '模型載入失敗，請重新整理頁面重試');
                });
        }
        
        // ==================== BVH 管理 ====================
        function buildBVH(mesh) {
            if (!mesh || !mesh.geometry) return;
            
            mesh.geometry.computeBoundsTree({
                strategy: 0, // CENTER strategy
                maxDepth: 40,
                maxLeafTris: 10,
                verbose: false
            });
            
            console.log('BVH 建構完成');
        }
        
        function disposeBVH(mesh) {
            if (!mesh || !mesh.geometry) return;
            if (mesh.geometry.boundsTree) {
                mesh.geometry.disposeBoundsTree();
                console.log('BVH 已清除');
            }
        }
        
        function toggleBVH(enabled) {
            if (!model || !model.children[0]) return;
            
            const mesh = model.children[0];
            
            if (enabled) {
                if (!mesh.geometry.boundsTree) {
                    buildBVH(mesh);
                }
            } else {
                disposeBVH(mesh);
            }
            
            console.log('BVH', enabled ? '已啟用' : '已停用');
        }
        
        function toggleBVHHelper(show) {
            if (!model || !model.children[0]) return;
            
            const mesh = model.children[0];
            
            if (show) {
                if (!bvhHelper) {
                    bvhHelper = new MeshBVHHelper(mesh, guiParams.helperDepth);
                    scene.add(bvhHelper);
                }
                bvhHelper.visible = true;
            } else {
                if (bvhHelper) {
                    bvhHelper.visible = false;
                }
            }
        }
        
        function updateBVHHelper(depth) {
            if (!bvhHelper) return;
            
            // 移除舊的 helper
            scene.remove(bvhHelper);
            bvhHelper.dispose();
            
            // 建立新的 helper
            if (guiParams.showBVHHelper && model && model.children[0]) {
                bvhHelper = new MeshBVHHelper(model.children[0], depth);
                scene.add(bvhHelper);
            }
        }
        
        // ==================== 光線產生 ====================
        function generateRayOrigins(count) {
            const origins = [];
            const radius = 2.5;
            
            // Fibonacci 球面取樣
            const phi = Math.PI * (3 - Math.sqrt(5)); // 黃金角度
            
            for (let i = 0; i < count; i++) {
                const y = 1 - (i / (count - 1)) * 2; // y 從 1 到 -1
                const radiusAtY = Math.sqrt(1 - y * y);
                const theta = phi * i;
                
                const x = Math.cos(theta) * radiusAtY;
                const z = Math.sin(theta) * radiusAtY;
                
                origins.push(new THREE.Vector3(
                    x * radius,
                    y * radius,
                    z * radius
                ));
            }
            
            return origins;
        }
        
        function initializeRays() {
            clearRays();
            
            const rayOrigins = generateRayOrigins(guiParams.rayCount);
            
            // 建立光線起點視覺化 (InstancedMesh)
            const originGeometry = new THREE.SphereGeometry(0.02, 8, 8);
            const originMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const originsMesh = new THREE.InstancedMesh(
                originGeometry,
                originMaterial,
                rayOrigins.length
            );
            
            const matrix = new THREE.Matrix4();
            rayOrigins.forEach((origin, i) => {
                matrix.setPosition(origin);
                originsMesh.setMatrixAt(i, matrix);
            });
            originsMesh.instanceMatrix.needsUpdate = true;
            
            rayOriginsGroup = new THREE.Group();
            rayOriginsGroup.add(originsMesh);
            scene.add(rayOriginsGroup);
            
            // 建立相交點容器 (稍後動態建立)
            intersectionPointsGroup = new THREE.Group();
            scene.add(intersectionPointsGroup);
            
            // 建立光線容器
            rayLinesGroup = new THREE.Group();
            scene.add(rayLinesGroup);
        }
        
        function updateRayCount(count) {
            guiParams.rayCount = count;
            initializeRays();
        }
        
        // ==================== 光線投射 ====================
        function castRays() {
            if (!model || !model.children[0]) return;
            
            const mesh = model.children[0];
            const rayOrigins = generateRayOrigins(guiParams.rayCount);
            const results = [];
            
            rayOrigins.forEach(origin => {
                // 光線方向指向模型中心
                const direction = new THREE.Vector3(0, 0, 0).sub(origin).normalize();
                
                raycaster.set(origin, direction);
                raycaster.far = 10;
                
                const intersects = raycaster.intersectObject(mesh, false);
                
                if (intersects.length > 0) {
                    results.push({
                        origin: origin,
                        intersection: intersects[0],
                        hasHit: true
                    });
                } else {
                    results.push({
                        origin: origin,
                        intersection: null,
                        hasHit: false
                    });
                }
            });
            
            return results;
        }
        
        function visualizeRays(results) {
            // 清除舊的視覺化
            clearRayVisualization();
            
            // 準備相交點
            const intersections = results.filter(r => r.hasHit);
            
            if (intersections.length > 0) {
                // 建立相交點 InstancedMesh
                const pointGeometry = new THREE.SphereGeometry(0.025, 8, 8);
                const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const pointsMesh = new THREE.InstancedMesh(
                    pointGeometry,
                    pointMaterial,
                    intersections.length
                );
                
                const matrix = new THREE.Matrix4();
                intersections.forEach((result, i) => {
                    matrix.setPosition(result.intersection.point);
                    pointsMesh.setMatrixAt(i, matrix);
                });
                pointsMesh.instanceMatrix.needsUpdate = true;
                
                intersectionPointsGroup.add(pointsMesh);
            }
            
            // 建立光線
            results.forEach(result => {
                const points = [];
                points.push(result.origin);
                
                if (result.hasHit) {
                    points.push(result.intersection.point);
                } else {
                    const endPoint = result.origin.clone().add(
                        new THREE.Vector3(0, 0, 0).sub(result.origin).normalize().multiplyScalar(5)
                    );
                    points.push(endPoint);
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: result.hasHit ? 0x00ff00 : 0x666666,
                    transparent: true,
                    opacity: guiParams.rayOpacity
                });
                const line = new THREE.Line(geometry, material);
                
                rayLinesGroup.add(line);
            });
        }
        
        function clearRayVisualization() {
            // 清除相交點
            if (intersectionPointsGroup) {
                intersectionPointsGroup.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                intersectionPointsGroup.clear();
            }
            
            // 清除光線
            if (rayLinesGroup) {
                rayLinesGroup.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                rayLinesGroup.clear();
            }
        }
        
        function clearRays() {
            if (rayOriginsGroup) {
                scene.remove(rayOriginsGroup);
                rayOriginsGroup.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            
            clearRayVisualization();
        }
        
        // ==================== GUI 建立 ====================
        function createGUI() {
            gui = new GUI();
            gui.title('控制面板');
            
            gui.add(guiParams, 'rayCount', 10, 200, 10)
                .name('光線數量')
                .onChange(value => updateRayCount(value));
            
            gui.add(guiParams, 'enableBVH')
                .name('啟用 BVH 加速')
                .onChange(value => toggleBVH(value));
            
            gui.add(guiParams, 'showBVHHelper')
                .name('顯示 BVH 視覺化')
                .onChange(value => toggleBVHHelper(value));
            
            gui.add(guiParams, 'helperDepth', 1, 20, 1)
                .name('BVH 顯示深度')
                .onChange(value => updateBVHHelper(value));
            
            gui.add(guiParams, 'rayOpacity', 0.1, 1.0, 0.1)
                .name('光線透明度')
                .onChange(value => {
                    if (rayLinesGroup) {
                        rayLinesGroup.children.forEach(line => {
                            if (line.material) {
                                line.material.opacity = value;
                            }
                        });
                    }
                });
            
            gui.add(guiParams, 'animate')
                .name('自動旋轉');
        }
        
        // ==================== UI 輔助函式 ====================
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
        
        function updateLoadingProgress(progress, message = null) {
            const bar = document.getElementById('loading-bar');
            const text = document.getElementById('loading-text');
            
            bar.style.width = progress + '%';
            
            if (message) {
                text.textContent = message;
            } else {
                text.textContent = Math.round(progress) + '%';
            }
        }
        
        function showError(message) {
            document.getElementById('error-message').textContent = message;
            document.getElementById('error').style.display = 'block';
            document.getElementById('loading').style.display = 'none';
        }
        
        function showPerformanceWarning(show) {
            document.getElementById('performance-warning').style.display = show ? 'block' : 'none';
        }
        
        // ==================== 動畫迴圈 ====================
        function animate() {
            requestAnimationFrame(animate);
            
            // 更新統計
            stats.begin();
            
            // 更新效能監控
            const fps = 1000 / stats.getFps();
            performanceMonitor.update(1 / fps * 1000);
            performanceMonitor.checkWarning();
            
            // 更新控制
            controls.update();
            
            // 自動旋轉模型
            if (guiParams.animate && model) {
                model.rotation.y += 0.005;
            }
            
            // 投射光線並視覺化
            if (loadingState.status === 'ready') {
                const results = castRays();
                visualizeRays(results);
            }
            
            // 渲染場景
            renderer.render(scene, camera);
            
            stats.end();
        }
        
        // ==================== 啟動應用程式 ====================
        init();
    </script>
</body>
</html>
